# services/tool_executor.py

import json
import subprocess
from typing import Dict, Any
from pathlib import Path

from config import config
from models.session import CommandContext
from utils.logging import console


class ToolExecutor:
    """Shared tool execution logic for both local and cloud AI handlers."""
    
    def __init__(self, ctx: CommandContext, use_complex_path_resolution: bool = False):
        self.ctx = ctx
        self.use_complex_path_resolution = use_complex_path_resolution
    
    def execute_tool(self, tool_call: Dict[str, Any]) -> str:
        """Execute a tool call and return the result as a string."""
        tool_name = tool_call.get("tool")

        if tool_name == "delete_path":
            return "[red]Error:[/] The 'delete_path' tool is disabled."

        if tool_name == "run_bash":
            return self._execute_bash_command(tool_call)
        
        # File operations require path
        path = tool_call.get("path")
        if not path:
            return self._get_helpful_path_error(tool_name)

        # Resolve path based on configuration
        try:
            path_for_mcp = self._resolve_path(path)
        except Exception as e:
            return self._get_path_resolution_error(path, str(e))

        if tool_name == "read_file":
            return self._execute_read_file(path_for_mcp)
        elif tool_name == "write_file":
            content = tool_call.get("content", "")
            return self._execute_write_file(path_for_mcp, content)
        elif tool_name == "list_dir":
            return self._execute_list_dir(path_for_mcp)
        else:
            return f"[red]Error:[/] Unknown tool: {tool_name}. Available tools: read_file, write_file, list_dir, run_bash"

    def _get_helpful_path_error(self, tool_name: str) -> str:
        """Generate helpful error message when path is missing."""
        examples = {
            "read_file": '{"tool": "read_file", "path": "config.py"}',
            "write_file": '{"tool": "write_file", "path": "script.py", "content": "print(\\'hello\\')"}',
            "list_dir": '{"tool": "list_dir", "path": "."}'
        }
        
        example = examples.get(tool_name, f'{{"tool": "{tool_name}", "path": "filename.txt"}}')
        
        return f"""[red]Error:[/] Path is required for {tool_name}.
        
‚úÖ Correct usage: {example}
üí° Use relative paths like "script.py" or "./folder/file.txt"
‚ùå Don't use absolute paths like "/Users/admin/Documents/file.txt" """

    def _get_path_resolution_error(self, original_path: str, error_msg: str) -> str:
        """Generate helpful error message for path resolution issues."""
        
        # Check if it looks like an absolute path
        if original_path.startswith('/') or original_path.startswith('\\'):
            return f"""[red]Path Error:[/] Cannot use absolute path '{original_path}'
            
üö´ Problem: You used an absolute path (starts with / or \\)
‚úÖ Solution: Use relative paths instead

Examples of correct paths:
- "script.py" (file in current directory)
- "./test.txt" (file in current directory)  
- "subfolder/file.py" (file in subdirectory)
- "../file.txt" (file in parent directory)

‚ùå Don't use: "/Users/admin/Documents/file.txt"
‚úÖ Instead use: "file.txt" (if in project directory)"""
        
        # Check if it's outside the sandbox
        if "outside" in error_msg.lower() or "sandbox" in error_msg.lower():
            return f"""[red]Security Error:[/] Path '{original_path}' is outside the allowed project directory.
            
üõ°Ô∏è  Security: All file operations must stay within the project directory
‚úÖ Solution: Use relative paths that stay within the project

Safe examples:
- "script.py" 
- "./data/file.txt"
- "src/main.py"

üö´ Unsafe: Paths that go outside the project directory"""
        
        # Generic path error with helpful suggestions
        return f"""[red]Path Error:[/] Invalid path '{original_path}': {error_msg}
        
üí° Path Tips:
1. Use relative paths: "filename.txt"
2. For current directory: "." or "./"
3. For subdirectories: "folder/file.txt"
4. Check spelling and file existence
        
Example correct usage:
{{"tool": "read_file", "path": "config.py"}}"""

    def _execute_bash_command(self, tool_call: Dict[str, Any]) -> str:
        """Execute a bash command."""
        command = tool_call.get("command")
        if not command:
            return """[red]Error:[/] Command is required for run_bash.
            
‚úÖ Correct usage: {"tool": "run_bash", "command": "ls -la"}
üí° Examples: "python script.py", "ls", "pwd", "mkdir folder" """
        
        try:
            process = subprocess.run(
                command, 
                shell=True, 
                capture_output=True, 
                text=True, 
                timeout=config.COMMAND_TIMEOUT, 
                cwd=self.ctx.current_dir if hasattr(self.ctx, 'current_dir') else self.ctx.root_path
            )
            
            stdout = process.stdout.strip()
            stderr = process.stderr.strip()
            
            if process.returncode == 0:
                return f"‚úÖ Command executed successfully:\n{stdout}" if stdout else "‚úÖ Command executed successfully (no output)"
            else:
                return f"‚ùå Command failed (exit code {process.returncode}):\n{stderr}" if stderr else f"‚ùå Command failed (exit code {process.returncode})"
                
        except subprocess.TimeoutExpired:
            return f"[red]Error:[/] Command '{command}' timed out after {config.COMMAND_TIMEOUT} seconds."
        except Exception as e:
            return f"[red]Error:[/] Failed to execute command '{command}': {e}"

    def _resolve_path(self, path: str) -> str:
        """Resolve path based on configuration."""
        if self.use_complex_path_resolution:
            # Complex path resolution for LocalCodingHandler
            try:
                # Convert to Path object and resolve
                path_obj = Path(path)
                
                # If it's already absolute, check if it's within root_path
                if path_obj.is_absolute():
                    if not path_obj.is_relative_to(self.ctx.root_path):
                        raise ValueError(f"Absolute path '{path}' is outside the project directory. Use relative paths like 'script.py' or './file.txt' instead.")
                    resolved_path = path_obj
                else:
                    # Relative path - resolve relative to root_path
                    resolved_path = (self.ctx.root_path / path).resolve()
                
                # Double-check sandbox constraints
                if not resolved_path.is_relative_to(self.ctx.root_path):
                    raise ValueError(f"Path '{path}' resolves outside the project directory. Use relative paths that stay within the project.")
                
                # Return path relative to root_path for MCP client
                return str(resolved_path.relative_to(self.ctx.root_path))
                
            except Exception as e:
                if "outside" in str(e) or "project directory" in str(e):
                    raise e  # Re-raise our custom message
                else:
                    raise ValueError(f"Invalid path '{path}'. Use relative paths like 'script.py' or './folder/file.txt'.")
        else:
            # Simple path resolution for DeepSeekAnalysisHandler
            return path

    def _execute_read_file(self, path: str) -> str:
        """Execute read_file operation."""
        response = self.ctx.mcp_client.read_file(path)
        
        if "error" in response:
            error_msg = response["error"].lower()
            
            if any(keyword in error_msg for keyword in ["unauthorized", "invalid api key", "path traversal"]):
                return """[red]Security Error:[/] File access denied - operation outside allowed sandbox.
                
üõ°Ô∏è  Security: Only files within the project directory can be accessed
‚úÖ Solution: Use relative paths like "config.py" or "./data/file.txt" """
            
            elif "not found" in error_msg or "no such file" in error_msg:
                return f"""[red]File Not Found:[/] Cannot find file '{path}'
                
üí° Solutions:
1. Check the filename spelling
2. Use {"tool": "list_dir", "path": "."} to see available files
3. Make sure you're using the correct relative path

Example: {"tool": "read_file", "path": "config.py"}"""
            
            else:
                return f"[red]Error:[/] Could not read file '{path}': {response.get('error', 'Unknown error')}"
        
        content = response.get("content", "")
        if not content:
            return f"üìÑ File '{path}' is empty or could not be read."
        
        return f"üìÑ Content of '{path}':\n{content}"

    def _execute_write_file(self, path: str, content: str) -> str:
        """Execute write_file operation."""
        response = self.ctx.mcp_client.write_file(path, content)
        
        if "error" in response:
            error_msg = response["error"].lower()
            
            if any(keyword in error_msg for keyword in ["unauthorized", "invalid api key", "path traversal"]):
                return """[red]Security Error:[/] File write denied - operation outside allowed sandbox.
                
üõ°Ô∏è  Security: Only files within the project directory can be written
‚úÖ Solution: Use relative paths like "script.py" or "./data/file.txt" """
            
            elif "permission" in error_msg:
                return f"""[red]Permission Error:[/] Cannot write to '{path}' - insufficient permissions
                
üí° Solutions:
1. Check if the directory exists
2. Make sure the file isn't read-only
3. Try a different filename

Example: {"tool": "write_file", "path": "new_script.py", "content": "print('hello')"}"""
            
            else:
                return f"[red]Error:[/] Could not write to file '{path}': {response.get('error', 'Unknown error')}"
        
        status = response.get("status", "unknown")
        if status == "success":
            content_preview = content[:50] + "..." if len(content) > 50 else content
            return f"‚úÖ Successfully wrote to '{path}' ({len(content)} characters)\nContent preview: {content_preview}"
        else:
            return f"‚ùå Write operation may have failed: {status}"

    def _execute_list_dir(self, path: str) -> str:
        """Execute list_dir operation."""
        response = self.ctx.mcp_client.list_dir(path)
        
        if "error" in response:
            error_msg = response["error"].lower()
            
            if any(keyword in error_msg for keyword in ["unauthorized", "invalid api key", "path traversal"]):
                return """[red]Security Error:[/] Directory access denied - operation outside allowed sandbox.
                
üõ°Ô∏è  Security: Only directories within the project can be accessed
‚úÖ Solution: Use relative paths like "." or "./subfolder" """
            
            elif "not found" in error_msg or "no such file" in error_msg:
                return f"""[red]Directory Not Found:[/] Cannot find directory '{path}'
                
üí° Solutions:
1. Check the directory name spelling
2. Use "." for current directory
3. Use relative paths like "./subfolder"

Example: {"tool": "list_dir", "path": "."}"""
            
            else:
                return f"[red]Error:[/] Could not list directory '{path}': {response.get('error', 'Unknown error')}"
        
        if "result" in response:
            if self.use_complex_path_resolution:
                # Complex formatting for LocalCodingHandler
                result_data = response["result"]
                if isinstance(result_data, dict):
                    files = result_data.get("files", [])
                    dirs = result_data.get("directories", [])
                    
                    output = f"üìÅ Contents of '{path}':\n"
                    if dirs:
                        output += "üìÇ Directories:\n" + "\n".join(f"  üìÅ {d}" for d in sorted(dirs)) + "\n"
                    if files:
                        output += "üìÑ Files:\n" + "\n".join(f"  üìÑ {f}" for f in sorted(files))
                    
                    if not dirs and not files:
                        output += "  (empty directory)"
                    
                    return output
                else:
                    return f"üìÅ Contents of '{path}':\n{json.dumps(result_data, indent=2)}"
            else:
                # Simple formatting for DeepSeekAnalysisHandler
                items = response["result"]
                files = items.get("files", [])
                dirs = items.get("directories", [])
                return f"Directory listing for '{path}':\nFiles: {files}\nDirectories: {dirs}"
        else:
            return f"[red]Error:[/] Invalid response format for directory listing"